{"version":3,"file":"Tokenizer.js","names":["TokenType","regex","TokenizerEngine","escapeRegExp","equalizeWhitespace","NestedComment","Tokenizer","constructor","cfg","rulesBeforeParams","buildRulesBeforeParams","rulesAfterParams","buildRulesAfterParams","tokenize","input","paramTypesOverrides","rules","buildParamRules","tokens","postProcess","validRules","type","BLOCK_COMMENT","nestedBlockComments","LINE_COMMENT","lineComment","lineCommentTypes","QUOTED_IDENTIFIER","string","identTypes","NUMBER","RESERVED_PHRASE","reservedWord","reservedPhrases","identChars","text","toCanonical","CASE","END","BETWEEN","LIMIT","reservedClauses","includes","undefined","RESERVED_CLAUSE","RESERVED_SELECT","reservedSelect","RESERVED_SET_OPERATION","reservedSetOperations","WHEN","ELSE","THEN","RESERVED_JOIN","reservedJoins","AND","OR","XOR","supportsXor","RESERVED_FUNCTION_NAME","reservedFunctionNames","RESERVED_KEYWORD","reservedKeywords","VARIABLE","variableTypes","variable","STRING","stringTypes","IDENTIFIER","identifier","DELIMITER","COMMA","OPEN_PAREN","parenthesis","extraParens","CLOSE_PAREN","OPERATOR","operator","operators","ASTERISK","DOT","paramTypes","named","quoted","numbered","positional","NAMED_PARAMETER","parameter","identifierPattern","paramChars","key","v","slice","QUOTED_PARAMETER","stringPattern","tokenKey","quoteChar","replace","RegExp","NUMBERED_PARAMETER","POSITIONAL_PARAMETER","filter","rule","Boolean","toUpperCase"],"sources":["../../src/lexer/Tokenizer.ts"],"sourcesContent":["import { Token, TokenType } from './token.js';\nimport * as regex from './regexFactory.js';\nimport { ParamTypes, TokenizerOptions } from './TokenizerOptions.js';\nimport TokenizerEngine, { TokenRule } from './TokenizerEngine.js';\nimport { escapeRegExp } from './regexUtil.js';\nimport { equalizeWhitespace, Optional } from '../utils.js';\nimport { NestedComment } from './NestedComment.js';\n\ntype OptionalTokenRule = Optional<TokenRule, 'regex'>;\n\nexport default class Tokenizer {\n  private rulesBeforeParams: TokenRule[];\n  private rulesAfterParams: TokenRule[];\n\n  constructor(private cfg: TokenizerOptions) {\n    this.rulesBeforeParams = this.buildRulesBeforeParams(cfg);\n    this.rulesAfterParams = this.buildRulesAfterParams(cfg);\n  }\n\n  public tokenize(input: string, paramTypesOverrides: ParamTypes): Token[] {\n    const rules = [\n      ...this.rulesBeforeParams,\n      ...this.buildParamRules(this.cfg, paramTypesOverrides),\n      ...this.rulesAfterParams,\n    ];\n    const tokens = new TokenizerEngine(rules).tokenize(input);\n    return this.cfg.postProcess ? this.cfg.postProcess(tokens) : tokens;\n  }\n\n  // These rules can be cached as they only depend on\n  // the Tokenizer config options specified for each SQL dialect\n  private buildRulesBeforeParams(cfg: TokenizerOptions): TokenRule[] {\n    return this.validRules([\n      {\n        type: TokenType.BLOCK_COMMENT,\n        regex: cfg.nestedBlockComments ? new NestedComment() : /(\\/\\*[^]*?\\*\\/)/uy,\n      },\n      {\n        type: TokenType.LINE_COMMENT,\n        regex: regex.lineComment(cfg.lineCommentTypes ?? ['--']),\n      },\n      {\n        type: TokenType.QUOTED_IDENTIFIER,\n        regex: regex.string(cfg.identTypes),\n      },\n      {\n        type: TokenType.NUMBER,\n        regex:\n          /(?:0x[0-9a-fA-F]+|0b[01]+|(?:-\\s*)?[0-9]+(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+(?:\\.[0-9]+)?)?)(?!\\w)/uy,\n      },\n      // RESERVED_PHRASE is matched before all other keyword tokens\n      // to e.g. prioritize matching \"TIMESTAMP WITH TIME ZONE\" phrase over \"WITH\" clause.\n      {\n        type: TokenType.RESERVED_PHRASE,\n        regex: regex.reservedWord(cfg.reservedPhrases ?? [], cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.CASE,\n        regex: /CASE\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.END,\n        regex: /END\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.BETWEEN,\n        regex: /BETWEEN\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.LIMIT,\n        regex: cfg.reservedClauses.includes('LIMIT') ? /LIMIT\\b/iuy : undefined,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_CLAUSE,\n        regex: regex.reservedWord(cfg.reservedClauses, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_SELECT,\n        regex: regex.reservedWord(cfg.reservedSelect, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_SET_OPERATION,\n        regex: regex.reservedWord(cfg.reservedSetOperations, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.WHEN,\n        regex: /WHEN\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.ELSE,\n        regex: /ELSE\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.THEN,\n        regex: /THEN\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_JOIN,\n        regex: regex.reservedWord(cfg.reservedJoins, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.AND,\n        regex: /AND\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.OR,\n        regex: /OR\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.XOR,\n        regex: cfg.supportsXor ? /XOR\\b/iuy : undefined,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_FUNCTION_NAME,\n        regex: regex.reservedWord(cfg.reservedFunctionNames, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_KEYWORD,\n        regex: regex.reservedWord(cfg.reservedKeywords, cfg.identChars),\n        text: toCanonical,\n      },\n    ]);\n  }\n\n  // These rules can also be cached as they only depend on\n  // the Tokenizer config options specified for each SQL dialect\n  private buildRulesAfterParams(cfg: TokenizerOptions): TokenRule[] {\n    return this.validRules([\n      {\n        type: TokenType.VARIABLE,\n        regex: cfg.variableTypes ? regex.variable(cfg.variableTypes) : undefined,\n      },\n      { type: TokenType.STRING, regex: regex.string(cfg.stringTypes) },\n      {\n        type: TokenType.IDENTIFIER,\n        regex: regex.identifier(cfg.identChars),\n      },\n      { type: TokenType.DELIMITER, regex: /[;]/uy },\n      { type: TokenType.COMMA, regex: /[,]/y },\n      {\n        type: TokenType.OPEN_PAREN,\n        regex: regex.parenthesis('open', cfg.extraParens),\n      },\n      {\n        type: TokenType.CLOSE_PAREN,\n        regex: regex.parenthesis('close', cfg.extraParens),\n      },\n      {\n        type: TokenType.OPERATOR,\n        regex: regex.operator([\n          // standard operators\n          '+',\n          '-',\n          '/',\n          '>',\n          '<',\n          '=',\n          '<>',\n          '<=',\n          '>=',\n          '!=',\n          ...(cfg.operators ?? []),\n        ]),\n      },\n      { type: TokenType.ASTERISK, regex: /[*]/uy },\n      { type: TokenType.DOT, regex: /[.]/uy },\n    ]);\n  }\n\n  // These rules can't be blindly cached as the paramTypesOverrides object\n  // can differ on each invocation of the format() function.\n  private buildParamRules(cfg: TokenizerOptions, paramTypesOverrides: ParamTypes): TokenRule[] {\n    // Each dialect has its own default parameter types (if any),\n    // but these can be overriden by the user of the library.\n    const paramTypes = {\n      named: paramTypesOverrides?.named || cfg.paramTypes?.named || [],\n      quoted: paramTypesOverrides?.quoted || cfg.paramTypes?.quoted || [],\n      numbered: paramTypesOverrides?.numbered || cfg.paramTypes?.numbered || [],\n      positional:\n        typeof paramTypesOverrides?.positional === 'boolean'\n          ? paramTypesOverrides.positional\n          : cfg.paramTypes?.positional,\n    };\n\n    return this.validRules([\n      {\n        type: TokenType.NAMED_PARAMETER,\n        regex: regex.parameter(\n          paramTypes.named,\n          regex.identifierPattern(cfg.paramChars || cfg.identChars)\n        ),\n        key: v => v.slice(1),\n      },\n      {\n        type: TokenType.QUOTED_PARAMETER,\n        regex: regex.parameter(paramTypes.quoted, regex.stringPattern(cfg.identTypes)),\n        key: v =>\n          (({ tokenKey, quoteChar }) =>\n            tokenKey.replace(new RegExp(escapeRegExp('\\\\' + quoteChar), 'gu'), quoteChar))({\n            tokenKey: v.slice(2, -1),\n            quoteChar: v.slice(-1),\n          }),\n      },\n      {\n        type: TokenType.NUMBERED_PARAMETER,\n        regex: regex.parameter(paramTypes.numbered, '[0-9]+'),\n        key: v => v.slice(1),\n      },\n      {\n        type: TokenType.POSITIONAL_PARAMETER,\n        regex: paramTypes.positional ? /[?]/y : undefined,\n      },\n    ]);\n  }\n\n  // filters out rules for token types whose regex is undefined\n  private validRules(rules: OptionalTokenRule[]): TokenRule[] {\n    return rules.filter((rule): rule is TokenRule => Boolean(rule.regex));\n  }\n}\n\n/**\n * Converts keywords (and keyword sequences) to canonical form:\n * - in uppercase\n * - single spaces between words\n */\nconst toCanonical = (v: string) => equalizeWhitespace(v.toUpperCase());\n"],"mappings":"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"}